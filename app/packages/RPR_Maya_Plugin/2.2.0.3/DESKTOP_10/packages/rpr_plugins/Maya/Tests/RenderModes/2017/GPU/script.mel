// TODO: mb dived template for material test and other tests
source shelfCommands.mel;
source maya_benchmark_common.mel;

//Scene Information:
//configs:
global string $resultsDirectoryName = "D:/jobs_launcher/work/MaxMaya/DESKTOP-V0T0AVM/packages/rpr_plugins/Maya/Tests/RenderModes/2017/GPU";
global string $testType = "RenderModes";
global string $reportName = "report_mel.json";

// [0] project name
// [1] model name
// [2] additional script that are called before render
// [3] additional File Name identifier
global string $sceneRenderData[] = {
		"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 1;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "1"
		//,"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 2;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "2",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 3;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "3",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 4;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "4",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 5;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "5",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 6;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "6",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 7;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "7",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 8;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "8",
		//"FeatureScenes", "RenderModes.mb", "setAttr \"RadeonProRenderGlobals.renderMode\" 9;setAttr \"RadeonProRenderGlobals.useRenderStamp\" 1;" , "9",
		//"FeatureScenes", "RPRToneMapping.mb", "setAttr \"RadeonProRenderGlobals.toneMappingType\" 3;" , "-AutoLinear",
		//"FeatureScenes", "RPRToneMapping.mb", "setAttr \"RadeonProRenderGlobals.toneMappingType\" 1; setAttr \"RadeonProRenderGlobals.toneMappingLinearScale\" 4;" , "-Linear-4",
		//"FeatureScenes", "RPRToneMapping.mb", "setAttr \"RadeonProRenderGlobals.toneMappingType\" 4;" , "-MaxWhite",
		//"FeatureScenes", "RPRToneMapping.mb", "setAttr \"RadeonProRenderGlobals.toneMappingType\" 2; setAttr \"RadeonProRenderGlobals.toneMappingPhotolinearSensitivity\" 1.5; setAttr \"RadeonProRenderGlobals.toneMappingPhotolinearExposure\" 1.5; setAttr \"RadeonProRenderGlobals.toneMappingPhotolinearFstop\" 1.5;" , "-PhotoLinear-1_5",
		//"FeatureScenes", "RPRToneMapping.mb", "setAttr \"RadeonProRenderGlobals.toneMappingType\" 5; setAttr \"RadeonProRenderGlobals.toneMappingReinhard02Postscale\" 2; setAttr \"RadeonProRenderGlobals.toneMappingReinhard02Prescale\" 2; setAttr \"RadeonProRenderGlobals.toneMappingReinhard02Burn\" 2;" , "-Reinhard02-222"

};

//gets material library path:
proc string getMatLibraryPath(){
	python( "import sys" );
	python("import fireRender.rpr_material_browser");
	python("reload(fireRender.rpr_material_browser)");
	string $libraryP = python("fireRender.rpr_material_browser.getLibPath()");

	if (size($libraryP)==0){
		//if material library is not installed:
		return "";
	}

	return $libraryP;
}

//////////////////////////
//Test Functions (Scenes):
//////////////////////////
proc mayaSceneTests(string $resultsDirectory, string $projectBase, string $resultFolder_color, string $resultFolder_opacity, string $useGPU[], string $sceneRenderData[]){
	string $renderViewName = getRenderWindowPanel();
    int $j = 0;
	int $i = 0;

    // Run render tests
	float $startTime = 0;
	float $testTime = 0;
    for ($j = 0 ; $j<size($sceneRenderData) ; $j += 4) {
		//clock start time:
		$startTime = `timerX`;

		string $projectFolderPath = $projectBase + $sceneRenderData[$j];
		string $sceneF = $sceneRenderData[$j+1];
		string $additionalFileNameId = $sceneRenderData[$j+3];
		string $sceneFile = substituteAllString($sceneF,".mb","") + $additionalFileNameId + ".jpg";
		string $additionalFuncCall = $sceneRenderData[$j+2];
		

		string $resultFileName_color = $resultFolder_color + $sceneFile;
		string $resultFileName_opacity = $resultFolder_opacity + $sceneFile;

		setProject($projectFolderPath);

		//open scene:
		openSceneFileAndSetRPRRender($sceneF,$useGPU);

		if (size($additionalFuncCall) > 0){
			eval $additionalFuncCall;
		}

		//we could use this for rendering animations.
		//however that would be not the same as batch rendering.
		currentTime -edit 0;

		//set RPR render to wait for render to finish:
		fireRender -waitForItTwo;

		// render current frame
		renderIntoNewWindow render;

		if (`filetest -f $resultFileName_color` == 0){
			//delete previous image if exists:
			sysFile -delete ($resultFileName_color);
		}
		if (`filetest -f $resultFileName_opacity` == 0){
			//delete previous image if exists:
			sysFile -delete ($resultFileName_opacity);
		}
		
		renderWindowEditor -edit  -dst "color" $renderViewName;
		renderWindowEditor -edit -com -writeImage $resultFileName_color $renderViewName;
		renderWindowEditor -edit  -dst "mask" $renderViewName;
		renderWindowEditor -edit -com -writeImage $resultFileName_opacity $renderViewName;

		//swap back to color so it can be viewed while rendering:
		renderWindowEditor -edit  -dst "color" $renderViewName;
		//calculate total test time:
		$testTime = `timerX -startTime $startTime`;

		global string $reportName;

		writeToJSONReport($resultsDirectory, $reportName, "\n {");
		writeFullJsonReport($resultsDirectory, $sceneF, $sceneFile, $testTime, $useGPU);
		if ($j+4 < size($sceneRenderData)){
			writeToJSONReport($resultsDirectory, $reportName, "\n },");
		}
		else{ 
			writeToJSONReport($resultsDirectory, $reportName, "\n }");
		}
		
		file -f -new;
	}
}

/////////////////////////////
//Test Functions (Materials):
/////////////////////////////
proc mayaMaterialTests(string $resultsDirectory, string $projectFolderPath, string $sceneFile, string $resultFolder, string $useGPU[], string $libraryPath, string $contentList[]){
	setProject($projectFolderPath);
	
	string $renderViewNameMatTesting = getRenderWindowPanel();

	int $i = 0;
	int $j = 0;
	string $folderPath = "";
	string $xmlPath = "";
	string $subContentList[] = {};
	string $materialTestNode = "materialTestNode";
	string $materialTestNodeSG = "materialTestNodeSG";
	string $resultFileName = "";
	string $resultFilePath = "";
	float $startTime = 0;
	float $testTime = 0;

	for (;$i < size($contentList); $i++){
		$folderPath = ($libraryPath + "/" + $contentList[$i]);
		if (`filetest -d $folderPath`){
			//directory:
			$subContentList = `getFileList -folder $folderPath -filespec "*.xml"`;
			if (size($subContentList) == 0){
				$subContentList = `getFileList -folder $folderPath -filespec "*.XML"`;
			}
			$j = 0;
			for (;$j < size($subContentList);$j++){
				//clock start time:
				$startTime = `timerX`;

				$resultFileName = $contentList[$i] + ".jpg";
				$resultFilePath = $resultFolder + $resultFileName;

				//open material test scene again to flush out changes:
				openSceneFileAndSetRPRRender($sceneFile,$useGPU);

				$xmlPath = $folderPath + "/" + $subContentList[$j];
				RPRXMLImport -file $xmlPath -importImages false -mn $materialTestNode;
				// probe03 object on scene
				select -r Probe03;
				sets -e -forceElement $materialTestNodeSG;

				fireRender -waitForItTwo;

				renderIntoNewWindow render;

				if (`filetest -f $resultFilePath` == 0){
					//delete previous image if exists:
					sysFile -delete ($resultFilePath);
				}

				renderWindowEditor -edit  -dst "color" $renderViewNameMatTesting;
				renderWindowEditor -edit -com -writeImage $resultFilePath $renderViewNameMatTesting;

				$testTime = `timerX -startTime $startTime`;

				global string $reportName;

				writeToJSONReport($resultsDirectory, $reportName, "\n {");
				writeFullJsonReport($resultsDirectory, $sceneFile, $resultFileName, $testTime, $useGPU);
				if ($i+1 < size($contentList)){
					writeToJSONReport($resultsDirectory, $reportName, "},");
				}
				else{
					writeToJSONReport($resultsDirectory, $reportName, "}");
				}

				file -f -new;
			}
		}
	}
}

//main function
global proc mayaBenchmark(int $wantedTests[]){

	global string $reportName;
	if (`filetest -f $reportName` == 0){
		//delete previous report if exists:
		sysFile -delete ($reportName);
	}

	//check plugin loaded
	if( `pluginInfo -query -loaded RadeonProRender` == 0){
    	loadPlugin RadeonProRender;
	}
    // updateRendererUI;
    // updateRenderOverride;

    // unifiedRenderGlobalsWindow;
    // updateRendererUI;
    // updateRenderOverride;

	// Force the window size to SPEC APC definition 1920x1024 30 pixels are not used to make way for window boarders
	// window -e -tlc 0 0 -wh 1920 1050 MayaWindow;

	string $scriptPath = `whatIs mayaBenchmark`;
	string $scriptPathTokens[];
	// tokenize $scriptPath " " $scriptPathTokens;
	tokenize $scriptPath "\n" $scriptPathTokens;

	string $pathArray[] = stringToStringArray($scriptPathTokens[4], "/");
	string $resultsDirectory = "";
	string $projectBase = "";
	
	$projectBase = "D:/jobs_launcher/tests/assets/Maya" + "/";

	int $a = 0;
	for ($a = 0; $a < size($pathArray)-1; $a++){ 		//-1 to delete *.mel name
		$resultsDirectory = $resultsDirectory + $pathArray[$a] + "/";
		print($resultsDirectory + "_\n");
	}
	
	global string $sceneRenderData[];
	global string $testType;
	string $resultColor = $resultsDirectory + "Color/";
	string $resultOpacity = $resultsDirectory + "Opacity/";

	if (`filetest -d $resultColor` == 0){
		sysFile -makeDir $resultColor;
	}
	if (`filetest -d $resultOpacity` == 0){
		sysFile -makeDir $resultOpacity;
	}

	string $temp = intArrayToString($wantedTests, " ");
	string $useGPU[] = stringToStringArray($temp, " ");

	print("resultsDirectory\n");
	print($resultsDirectory + "\n");

	if (`match "Materials" $testType` == "Materials"){
		string $matProjectFolderPath = $projectBase + "MaterialLibraryScene/";
		string $matSceneName = "MaterialTestScene.mb";
		string $libPath = getMatLibraryPath();

		//all materials in library - list of folders	
		string $contentList[];
		global string $sceneRenderData[];
		if (`strcmp $sceneRenderData[0] "*"`){
			$contentList = $sceneRenderData;
		}
		else{
			$contentList = `getFileList -folder $libPath`;
		}

		createExpectedLogMaterials("expected.json", $resultsDirectory, $contentList, $useGPU);

		writeToJSONReport($resultsDirectory, $reportName, "[");
		mayaMaterialTests($resultsDirectory, $matProjectFolderPath, $matSceneName, $resultColor, $useGPU, $libPath, $contentList);
		writeToJSONReport($resultsDirectory, $reportName, "\n]");	
	}else{
		createExpectedLog("expected.json", $resultsDirectory, $sceneRenderData, $useGPU);

		writeToJSONReport($resultsDirectory, $reportName, "[");
		mayaSceneTests($resultsDirectory, $projectBase, $resultColor, $resultOpacity, $useGPU, $sceneRenderData);
		writeToJSONReport($resultsDirectory, $reportName, "\n]");	
	}

	file -f -new;

	// close file with script editor trace
	string $traceFile = getenv( "MAYA_CMD_FILE_OUTPUT" );
	int $descriptor = `cmdFileOutput -o $traceFile -q`;
	if ( -1 != $descriptor ) {
	    cmdFileOutput -close $descriptor;
	}

	evalDeferred("quit -abort");
}